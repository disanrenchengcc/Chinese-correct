#依据目前我所了解的一些，中文文本纠错大致整理
##错误大题分成两类，一类是拼写类的表面错误，第二类是较为困难的语法错误。
####一.对于第一类，较为简单，基于拼音、字形或者编辑距离等相似度进行候选召回备选词进行错误词语的替换即可

####二.对于第二类
1.使用语言模型，我总结出语言模型使用的三种思路：
检测句子流畅度
检测错误词语
生成备选词（句子）
这三个思路使用的语言模型的原理是一样的，只是使用的角度不同。检测句子流畅度是扫描整个句子，计算每个字/词的概率而后乘起来
（鉴于字词概率都会远小于1，导致乘起来后值过小，一般语言模型都会采用log概率，即计算出概率后再取log），将乘出来的数成为句子流畅度。
检测错误词语就是通过处理前面的文本，计算下一个已知的词的概率，若是概率低于阈值（阈值一般是人工设定），那么就可以标记成错误词。而只要将下一个词扩展成词表，
对词表里每个词都求一个概率，然后取出概率最大的词，那么我们就可以做到备选词生成了，若是不断把概率最大的备选词填入原本句子中再输入语言模型，就可以做到句子生成了。

例如，对于一句话 "STA 我 今天 吃 苹果 了 END"：

检测句子流畅度的话，就是计算 "STA"后是"我"的概率，【"STA", "我"】后面是"今天"的概率。。到 【"STA", "我", "今天", "吃", "苹果", "了"】
后面是"END"的概率，而后将所有概率取log乘起来，得到句子流畅度分数。
检测错误词语，同样也是计算一遍所有词语的概率，而后将他们放到一起，根据认为设定的阈值筛出概率较低的词。
生成备选词，则是首先扫描到例如 "STA 我 今天 吃"，而后计算词表中每个词的概率，即 若是将一个词接到前面扫描的部分的后面，
那个词的概率，若词表有【"STA", "我", "今天", "吃", "苹果", "了", "END"】这么些词，那就是计算【"STA 我 今天 吃" + "STA"】的概率，【"STA 我 今天 吃" + "我"】的概率。。。，【"STA 我 今天 吃" + "END"】概率，
每个加进去的词都会得到一个概率，若是取概率最大的词出来即可作为备选词了。

2.可以将检错问题视作序列标注问题，正确的标0，错误的标1，将句子词或字序列输入模型后根据预测值得到错误字词。

序列标注模型实际上就是个多分类模型，当问题是检错的时候就是个二分类模型，它和其它数据型分类模型的区别在于构建特征的时候需要考虑时序特性，就是利用LSTM将文本序列信息嵌入到特征向量中。
在检错方面得到一定成果之后，我们开始结合检错和备选词生成进行句子纠错：首先将错误词进行备选词替换，之后语言模型检测句子流畅度，挑选流畅度最高或者困惑度最低的句子作为最终正确的句子。

#序列标注模型 VS 语言模型
首先用训练集进行对比：
序列标注模型语料需要使用标注好的数据
语言模型需要使用正确的数据
高下立判。序列标注模型需要标注好的数据才可以训练，对学术界而言自然不是问题，但对于工业界和夹在工业学术之间的我们显然不希望在构建数据上花费大量时间和精力。而语言模型只需要使用正确的句子就可以，而正确的句子在网络上到处都是，Wikipedia、百度百科、知乎什么的，一爬一大堆，虽然还是要注意分布相似性问题，但序列标注模型也同样需要考虑。因此语言模型在训练数据准备上无疑优于序列标注模型很多。
而后根据模型复杂度进行比较：

序列标注模型最后的全连接层只需要和类别数目相同的神经元，在本文中即两个神经元，分别代表正确和错误。
语言模型最后的全连接层需要词表大小的神经元。
在模型复杂度方面序列标注模型要占优势，毕竟词表少说也有上千上万个，需要更新的参数数目瞬间就多了几个量级。

最后将模型用途进行比较：

序列标注模型仅能用于标注。
语言模型可以用于检测句子流畅度、检测错误词、生成备选词。
用途一比，语言模型又大胜，序列标注模型仅专注于标注，而语言模型可以一模型多用，最后全连接层使用词表大小的神经元大大增加了语言模型的能力。

如此对比一看，序列标注模型或许更适合在学术界使用，毕竟他们拥有大量纯粹的数据，而语言模型更适合工业界使用超大量语料训练，得到一个核弹级多功能通用模型。


#参考：
##相关比赛:Overview of the NLPCC 2018 Shared Task: Grammatical Error Correction
##最新论文2020年:Spelling Error Correction with Soft-Masked BERT